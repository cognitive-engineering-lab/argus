#+title: Notes
#+author: Gavin Gray

* Ad-hoc Polymorphism at large

** Scala2 (implicits)
Most of this information is gleaned from the paper "Scala Implicits are
Everywhere" [[https://arxiv.org/pdf/1908.07883.pdf]]

There are really two separate mechanisms at play for /implicits/, each achieves
something different but together they are a menace.

*** Implicit conversions
Conversions are defined as an implicit function or class (or value of function
type) and the compiler will search for implicit conversions to make the program type-check.

#+begin_src scala
// paper pg 4.
case class Duration(time: Long, unit: TimeUnit) {
  def +(o: Duration) = Duration(time + unit.convert(o.time, o.unit), unit)
}

implicit class Int2Duration(that: Int) {
  def seconds = new Duration(that, SECONDS); def minutes = new Duration(that, MINUTES)
}

5.seconds + 2.minutes // Duration(125L, SECONDS )
#+end_src

As shown above, implicit conversion are important for Scala DSLs.

*** Implicit parameters
Implicit parameters are filled in automatically by the compiler at the call site
if there is an available implicit value. The name of the value is important, and
thus introduces all the typicaly problems with variable naming (shadowing, etc).


*** Important idioms
- Late Trait Implementation, because classes are nominally typed, in order to
  extend a class with a new trait a wrapper needs to be used. An implicit
  conversion is then added when a specific  trait bound is required (but was
  originally not declared).

- Extension methods, adding methods to an existing class.

- Type Classes, probably the most important use:

#+begin_src scala
trait Show[T] {
  def show(x: T): String
}

def show[T](x: T)(implicit ev: Show[T]) = ev.show(x)

// struct Shape
case class Shape(n: Int)

// impl Show for Shape { ... }
implicit object shapeShow extends Show[Shape] {
  def show(x: Shape) = x.n match {
    case 3 => "a triangle";
    case 4 => "a square"
    case _ => "a shape with $n sides"
  }
}

// impl<T: Show> Show for List<T> { ... }
implicit def listShow[T](implicit ev: Show[T]) = new Show[List[T]] {
  def show(x: List[T]) = x.map(x => ev.show(x)).mkString("a list of [", ", ", "]")
}

// Syntax extension, allowing one to write x.show instead of show(x)
// this is more Scala specific and bridges the OO-class and functional-typeclass world.
implicit class ShowOps[T](x: T)(implicit s: Show[T]) { def show = s.show(x) }
#+end_src

- Type Proofs,
  #src_scala{class List[A] { def flatten[B](implicit ev: A => List[B]): List[B]
  }} a type proof generator can be written #src_scala{implicit def isEq[A]: A=>A
  = new =>[A,A]{}} which ensures that ~List(List(1)).flatten = List(1)~ but
  ~List(1).flatten~ results in the error /No implicit view available from ~Int => List[B]~.

- Contexts, threading a context through the environment can be done implicitly.
  E.g., in Rust instead of requiring a ~TyCtxt~ parameter, it could be declared
  implicitly and the compiler will pass it around automatically. This isn't
  /directly/ used in Rust, however, async Rust /does/ desugar into a use of Traits
  which achieves a similar result as threaded Scala code.

Some of the problems with implicits are seen in Rust, I'll lay these out later.
But some things are unique. But there are differences.

- Conversion, proof generators, typeclass witnesses, all can be /named/. This is
  different from Rust, where impl blocks are all anonymous. They can be imported
  by name, however, in Rust when a Trait gets imported /all/ of the implementors
  are imported.

- Conversions are implicit in Scala where they would be explicit in Rust. For
  example, in Rust you would /at least/ need a call to ~.into()~ to make a
  conversion, but in Scala the compiler can insert these silently.

** Scala3 (givens)

** Swift (protocols)

** Rust (traits)
- All impl blocks are anonymous, this means you get them all or none (with no
  trait import). This is in contrast to Scala implicits and givens, which can be
  named and imported named.

In the implicits paper, the authors identify that the implicit search is on of
the problems when trying to understand implicits. In Rust, there is no local vs
implicit scope, /everything/ is in the implicit scope. There are subtle
differences, however, in Scala2 there is no global coherence. This allows for
richer type declarations, but this also causes the compiler to lack information
when reporting type errors. The authors say this is why the compiler would error
out with /could not find implicit value/ or /member not found/. To avoid name
collision library maintainers try to obfuscate the implicit names to avoid
collision, but this of course affects ergonomics. Rust's inclusion of global
coherence affects ergonomics in a different way, blanket implementations are
provided to try and cover all use cases making code search harder.

Rust does not (to my knowledge) insert any code, making the resolution easier
and more predictable than Scala's. *However*, library authors will use macros to
automatically derive a trait implementation, which can cause confusing errors in
expanded code. This isn't specific to /traits/ but it is a result of global
coherence rules.

Rust idioms of why someone would want to use traits:
- Conversions, ~into~, ~cast~, etc. I think this would even include the Bevy example
  of where you are converting a function ~Fn~ (common type) into a ~System~
  (domain-specific type). This conversion is common, e.g., Diesel's ~str~ to ~Text~.

- Type proofs, ~nalgebra~, ~diesel~, ~Send~, ~Sync~, etc. This is probably the most
  common use case, trying to get type safety by requiring certain trait bounds
  on a type. This isn't necessarily an exclusive use-case from the previous. For
  example, the Bevy example uses /both/ type proofs (by requiring function
  parameter bounds) and implicit casting. This is used extensively in Rocket,
  Diesel, etc.

- Dynamic dispatch, ~dyn~, ~impl~, etc. ???

*** Conversions
**** Simple conversions
#+begin_src rust
// Example from:
// https://rust-lang.github.io/chalk/chalk_ir/cast/index.html
#![allow(dead_code)]

struct A {}
struct B {}
struct C {}

impl B {
    fn foo(self) { }
}

trait CastTo<T>: Sized {
    fn cast_to(self) -> T;
}

trait Cast: Sized {
    fn cast<U>(self) -> U
    where
        Self: CastTo<U>,
    {
        self.cast_to()
    }
}

impl<T> Cast for T {}

// CastTo relationships

macro_rules! rels {
    ($($a:ident --> $b:ident,)*) => {
        $(
            impl CastTo<$b> for $a {
                fn cast_to(self) -> $b {
                    $b {}
                }
            }
        )*
    }
}

rels! {
    B --> A,
    C --> B,
    C --> A,
}

// Client code

fn requires(_: A) { }

fn client(c: C) {
    requires(c.cast())
}

fn main() {}
#+end_src

**** Marker conversions


** Haskell (typeclasses)

** Feature matrix

| Language | Global Coherence | Multi-param Instances |
|----------+------------------+-----------------------|
| Rust     | X                | X                     |
| Haskell  |                  |                       |
| Swift    |                  |                       |
| Scala2   |                  | X                     |
| Scala3   |                  |                       |


***** [ ] TODO insert your research from Haskell / Scala.

***** [ ] TODO continue Will's dabbling with Java to compare diagnostics


* How does /rustc/ report obligations?

There's two ways to report a "selection error":
- ~report_fulfillment_error~ (this is kind of the entry, /it can call the below/) [[file:~/dev/prj/rust/compiler/rustc_trait_selection/src/traits/error_reporting/type_err_ctxt_ext.rs::1291]]

- ~report_selection_error~ : [[file:~/dev/prj/rust/compiler/rustc_trait_selection/src/traits/error_reporting/type_err_ctxt_ext.rs::351]]

The function ~report_fulfillment_errors~ is where we actually see the selection of
errors reported.  There's even a struct field ~reported_trait_errors~ to remember
what's been reported. One of the things they do is sort by "importance". ~T:
Sized~ and ~T: WF~ predicates are /least important/, as are coercion errors. [[file:~/dev/prj/rust/compiler/rustc_trait_selection/src/traits/error_reporting/type_err_ctxt_ext.rs::111]]

Two passes are used to filter errors before reporting. Ties are broken by
ordering, and rustc orders by "when the error was logged."
1. Errors are suppressed if they (a) have the same span, or (b) one implies the
   other (the "other" is then suppressed).
2. All errors that were not suppressed, and errors that aren't a result of
   desugaring, are then reported.

This process currently happens all within the same function, I wonder if we
could separate it into two functions: one that orders, filters, and fixes
errors, the second actually reporting them. This way, we could use the same
preprocess step to better match the compiler.

***** [ ] TODO talk with the diagnostics team

***** [ ] TODO investigate ambiguity errors and where to siphon obligations.


* Thinking about
***** [ ] TODO we need an understanding of how people debug trait errors. (all categories)
***** [ ] TODO what is our set of /metric problems/.


* Checklist Î±-release
** IDE
***** [ ] TODO display the now serialized types.
***** [ ] TODO clean up the "obligations manager." The interactions are a little wierd currently.


** RUSTC (thins to upstream)
***** [ ] TODO why did the serde code not trigger anything in ARGUS? Investigate this a little further, it's possible there's one more route that would make catching these obligations more robust. (Or it's possible that the expansion uses the old trait solver.)
***** [ ] TODO ~inspect_typeck~ (or another entry point).
***** [ ] TODO exposing obligations on the ~FnCtxt~.
- [ ] I'm currently catching all fulfilled obligations, which is a bit messy.
  There are /lots/, many of which are unimportant. Is this what we want?
- [ ] I also have Will's net in the ~TypeErrCtxt~, which is great for getting the
  errors that were reported, but does having both make the changes a harder
  sell? Additionally, this net needs to be behind the same unstable flag as all obligations.

***** [ ] TODO ^ use the ~CandidateSource::ParamEnv~, there doesn't seem to be a clear path to its inclusion, but this is the second most important candidate probe kind.


** ARGUS
***** [ ] TODO support serialization A note on seri
****** A note on serializing Node Goals
Each goal needs to be serialized in its own context. This is stored in the
~InsepctGoal~ struct, so that's not hard. However, I've been running into issues
when serializing inference variables, and paths. For inference variables, it
seems like I'm fudging something up. With a frequency between rarely and
frequent, I get index out of bounds exceptions with the inference variables.
Paths on the other hand have been a complete nightmare. I've opted for a more
simplistic approach to generating the paths, but even that runs into issues!
(See [[https://github.com/rust-lang/rust/pull/89738]] and related comments in the
pretty file about infinite recursion when resolving the paths.) Not great. I
think I need to talk to someone about this because it's been a /royal/ headache.
(Oh, and aliases are going to be even more of a nightmare.)
***** [X] TODO filter root obligations that are extraneous.
- [ ] we discussed these as being obligations of the form ~_: TRAIT~ or ~(): TRAIT~.
- [ ] but how does rustc pick the ambiguity error to talk about? (I have a loose
  idea; it's a good idea to try and nab Michael Goulet's attention.)

***** [ ] TODO test on the set of example programs, and a few others to try and catch possible bugs.
***** [ ] TODO tests???

