<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Argus: a trait debugger for Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="book/mdbook-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="trait-debugging-101.html"><strong aria-hidden="true">1.</strong> Trait Debugging 101</a></li><li class="chapter-item expanded "><a href="typestate.html"><strong aria-hidden="true">2.</strong> Trait Methods and Typestate</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Argus: a trait debugger for Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="trait-debugging-101"><a class="header" href="#trait-debugging-101">Trait Debugging 101</a></h1>
<p>Traits are a pervasive language feature in Rust: Copying, printing, indexing, multiplying, and more common operations use the Rust trait system. As you use more of the language, and utilize the numerous published crates, you will inevitably encounter more traits. Popular crates in the Rust ecosystem use traits to achieve strong type safety, such as the Diesel crate that relies on traits to turn invalid SQL queries into type errors. Impressive!</p>
<p>Unfortunately, traits also obfuscate type errors. Compiler diagnostics become increasingly complex alongside the types and traits used. This guide demonstrates <em>trait debugging</em> in Rust using a new tool, Argus, developed by the <a href="https://cel.cs.brown.edu/">Cognitive Engineering Lab</a> at Brown University. The examples used in this tutorial are <a href="https://github.com/cognitive-engineering-lab/argus-test">available online</a>, we recommend you follow along at home.</p>
<h2 id="your-first-web-server"><a class="header" href="#your-first-web-server">Your First Web Server</a></h2>
<p><a href="https://docs.rs/axum/latest/axum/">Axum</a> is a popular Rust web application framework, a great example of how traits can obfuscate type errors. We will use Axum to build a web server, and Argus to debug the trait errors; here’s our starting code.</p>
<pre><code class="language-rust ignore compile_fail">struct LoginAttempt {
  user_id: u64,
  password: String,
}

fn login(attempt: LoginAttempt) -&gt; bool {
  todo!()
}

#[tokio::main]
async fn main() {
  let app = Router::new()
    .route("/login", get(login));

  let listener = TcpListener::bind("0.0.0.0:3000")
    .await.unwrap();
  axum::serve(listener, app).await.unwrap();
}</code></pre>
<p>Oh no, our server doesn’t type check. Surely, the error diagnostic will tell us why—</p>
<pre><code class="language-text">error[E0277]: the trait bound `fn(LoginAttempt) -&gt; bool {login}: Handler&lt;_, _&gt;` is not satisfied
   --&gt; src/main.rs:14:49
    |
14  |     let app = Router::new().route("/login", get(login));
    |                                             --- ^^^^^ the trait `Handler&lt;_, _&gt;` is not implemented for fn item `fn(LoginAttempt) -&gt; bool {login}`            
    |                                             |
    |                                             required by a bound introduced by this call
    |
    = help: the following other types implement trait `Handler&lt;T, S&gt;`:
              &lt;Layered&lt;L, H, T, S&gt; as Handler&lt;T, S&gt;&gt;
              &lt;MethodRouter&lt;S&gt; as Handler&lt;(), S&gt;&gt;
note: required by a bound in `axum::routing::get`
</code></pre>
<p>in a long-winded way the diagnostic has said “<code>login</code> does not implement <code>Handler</code>.” But as the authors we <em>intended</em> for <code>login</code> to be a handler. The diagnostic hasn’t provided much specific information as to why the code doesn’t type check.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="trait-debugging-101.html#admonition-note"></a>
</div>
<div>
<p>Going forward we will write <code>{login}</code> to abbreviate the type of <code>login</code>, <code>fn(LoginAttempt) -&gt; bool</code>, which is far too verbose to repeat over and over.</p>
</div>
</div>
<p>When the error diagnostic says “trait bound <code>Bleh</code> is not satisfied”, it’s a great opportunity to use Argus.</p>
<h2 id="down-the-search-tree"><a class="header" href="#down-the-search-tree">Down the Search Tree</a></h2>
<p>In Rust we write type definitions and trait implementations separately—we refer to trait implementations as “impl blocks.” The inner compiler component called the <em>trait solver</em> is responsible for answering queries like “Does <code>{login}</code> implement <code>Handler</code>?” such queries appear as trait bounds in the source code. The trait solver searches through the impl blocks trying to find whether or not the trait bound holds.</p>
<p>In this post we will be using the <em>search tree</em> a data structure produced by the trait solver that describes how it searched impl blocks, and why—or why not—a particular trait bound holds.</p>
<p>Here’s an illustrative diagram of the Axum-error search tree. Argus provides the search tree in a different format, similar to a directory tree, as you shall see further on.</p>
<pre class="mermaid">---
title: Search tree produced by the Axum trait error
---
graph TD
  root[&quot;{login}: Handler&quot;]
  implRespH[&quot;impl Handler&lt;IntoResponseHandler, S&gt; for T\nwhere\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;T: IntoResponse&quot;]
  intoResp[&quot;{login}: IntoResponse&quot;]
  implH[&quot;impl Handler&lt;M, S&gt; for F\nwhere\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;F: FnOnce(T1) -&gt; Res,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Res: IntoResponse + Send,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;T1: FromRequest&quot;]
  isFunc[&quot;{login}: FnOnce(LoginAttempt) -&amp;gt; bool&quot;]
  boolFut[&quot;bool: IntoResponse&quot;]
  loginARqst[&quot;LoginAttempt: FromRequest&quot;]
  
  root -.-&gt; implRespH
  implRespH --T = {login}--&gt; intoResp
  root -.-&gt; implH
  implH --F = {login}, T1 = LoginAttempt, Res = bool--&gt; isFunc
  implH --Res = bool--&gt; boolFut
  implH --T1 = LoginAttempt--&gt; loginARqst
  
  class root,implRespH,intoResp,implH,boolFut,loginARqst cssFailure
  class isFunc cssSuccess
  
  classDef default fill:#fafafa, stroke-width:3px, text-align:left
  classDef cssSuccess stroke:green
  classDef cssFailure stroke:red
  linkStyle 0,1,2,4,5  stroke:red
  linkStyle 3  stroke:green, stroke-width:4px
</pre>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="trait-debugging-101.html#admonition-note-1"></a>
</div>
<div>
<p>We elided trivial bounds to declutter the above diagram. Don’t panic if you open the Argus panel and see some bounds not shown here.</p>
</div>
</div>
<p>Dotted lines represent an <strong>Or</strong> relationship between parent and child. That is, exactly one of the child blocks needs to hold—outlined in green. We see dotted lines coming from the root bound and extending to the impl blocks. Impl blocks always form an Or relationship with their parent.</p>
<p>Solid lines represent <strong>And</strong> relationships between parent and child. That is, every one of the child blocks needs to hold. We see solid lines coming from impl blocks and extending to the nested constraints. Constraints always form an And relationship with their parent impl block.</p>
<p>Traversing the tree from root to leaf is what’s referred to as “Top-Down” in the Argus extension. This view represents the full search tree, in other words, <em>how</em> the trait solver responded to the query.</p>
<p>Comparing the search tree to the error diagnostic is curious: Why did the error diagnostic mention the <em>root bound</em>, <code>{login}: Handler&lt;_, _&gt;</code>, instead of a more specific failing bound at the tree leaves? The compilers job is to take the search tree and tell you something useful about why the trait bound failed—but Rust can’t tell you everything, because there’s simply too much information. So it picks the most specific failure it can, which in this case is the root node. Rust doesn’t know which of the two impl blocks you <em>intended</em> to use and it won’t speculate on your behalf.</p>
<p>We developed Argus so you can identify the <em>specific failures</em> that led to a particular trait error; Argus can provide more specific details on a trait error than Rust is willing to summarize in a single text-based diagnostic message. Let’s walk through the search tree as presented in Argus’ Top-Down view.</p>
<p style="text-align:center"><img src="assets/axum-hello-server/top-down-root-highlighted.png" alt="Search tree initial bound" width="600"></p>
<p>Highlighted at the top in orange is the search tree root. Argus represents the search tree in a directory view sort of way, so the orange node is equivalent to the tree root node in the illustrative diagram. In the Argus tree you expand the nodes’ children by clicking on the line. Notice how we still use solid and dotted lines to represent the parent child relationship, they now appear to the left of the node.</p>
<p style="text-align:center"><img src="assets/axum-hello-server/top-down-impl-highlighted.png" alt="Search tree found impl" width="600"></p>
<p>Above we show one branch in the search tree for the function handler impl block—highlighted in green. In this branch we unify the type variables</p>
<pre><code class="language-text">F = fn(LoginAttempt) -&gt; bool
T1 = LoginAttempt
Fut = Future&lt;Output = Res&gt;
Res = bool
</code></pre>
<p>and add the where-clause constraints as children of the impl block. Notice the constraint <code>Res: IntoResponse</code>, given that <code>Res = bool</code>, the constraint requires that booleans implement <code>IntoResponse</code>, but they don’t. This is one of the root causes of the error and we shal look at how to fix the problem in the following section. But before we jump back to the code and start fixing issues, let’s reflect on the Argus interface and see how we can reach the same conclusion faster.</p>
<p style="text-align:center"><img src="assets/axum-hello-server/top-down-error-highlighted.png" alt="Search tree found impl" width="600"></p>
<p>The screenshots included so far of the trait search tree are from the Top-Down view in Argus. This means we view the search just as Rust performed it: We started at the root question <code>{login}: Handler&lt;_, _&gt;</code>, descended into the impl blocks, and found the failing where-clause in a tree leaf—highlighted in red. There’s a second failing bound, but we’ll come back to that in the next section. The insight is that errors are <em>leaves</em> in the search tree, so the Top-Down view doesn’t prioritize showing you errors, but rather the full trait solving process.</p>
<h2 id="up-the-search-tree"><a class="header" href="#up-the-search-tree">Up the Search Tree</a></h2>
<p>What if you want to see the errors first? Argus provides a second view of the tree called the Bottom-Up view. The Bottom-Up view starts at the error leaves and expanding node children traverses up the tree towards the root. This view prioritizes showing you errors first.</p>
<p>The Bottom-Up view is the <em>inverted</em> search tree. You start at the leaves and traverse to the root. Here’s the bottom-up version of the Axum error search tree.</p>
<pre class="mermaid">---
title: Bottom-Up view of the search tree.
---
graph TD
  root[&quot;{login}: Handler&quot;]
  implRespH[&quot;impl Handler&lt;IntoResponseHandler, S&gt; for T\nwhere\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;T: IntoResponse&quot;]
  intoResp[&quot;{login}: IntoResponse&quot;]
  implH[&quot;impl Handler&lt;M, S&gt; for F\nwhere\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;F: FnOnce(T1) -&gt; Res,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Res: IntoResponse + Send,\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;T1: FromRequest&quot;]
  isFunc[&quot;{login}: FnOnce(LoginAttempt) -&amp;gt; bool&quot;]
  boolFut[&quot;bool: IntoResponse&quot;]
  loginARqst[&quot;LoginAttempt: FromRequest&quot;]
  

  implRespH -.-&gt; root
  intoResp --&gt; implRespH
  implH -.-&gt; root
  isFunc --&gt; implH
  boolFut --&gt; implH
  loginARqst --&gt; implH
  
  class root,implRespH,intoResp,implH,boolFut,loginARqst cssFailure
  class isFunc cssSuccess
  
  classDef default fill:#fafafa, stroke-width:3px, text-align:left
  classDef cssSuccess stroke:green
  classDef cssFailure stroke:red
  linkStyle 0,1,2,4,5 stroke:red,color:red
  linkStyle 3 stroke:green, stroke-width:4px, color:green
</pre>
<p>Argus sorts the failing leaves in the Bottom-Up view by which are “most-likely” the root cause of the error. No tool is perfect, and Argus can be wrong! If you click on “Other failures,” which appears below the first shown failure, Argus provides you a full list.</p>
<video controls>
  <source alt="Bottom-Up Argus view" src="assets/axum-hello-server/bottom-up-start.mp4" type="video/mp4" />
</video>
<p>The above demonstrates that Argus identifies <code>Res: IntoResponse</code> as a root cause of the overall failure in addition to the second failure: <code>LoginAttempt: FromRequestParts&lt;_, _&gt;</code>. The note icon in the Bottom-Up view indicates that the two failures must be resolved together if you want to us the function as a handler.</p>
<video controls>
  <source alt="Fix Future and IntoResponse" src="assets/axum-hello-server/async-fix-response.mp4" type="video/mp4" />
</video>
<div id="admonition-note-2" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-2-title">
<div class="admonition-title">
<div id="admonition-note-2-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="trait-debugging-101.html#admonition-note-2"></a>
</div>
<div>
<p>The list of trait implementors is equivalent to what you’d find in Rust documentation. See for yourself in the <a href="https://docs.rs/axum/latest/axum/response/trait.IntoResponse.html#foreign-impls"><code>IntoResponse</code> documentation</a>. Rust documentation makes a distinction between “implementations on foreign types” and “implementors,” Argus lists both kinds of impl block together.</p>
</div>
</div>
<p>Moving forward let’s finally fix the last failing bound and get the code to type check.</p>
<video controls>
  <source alt="Finished debugging" src="assets/axum-hello-server/axum-type-checks.mp4" type="video/mp4" />
</video>
<p>The above video contains a lot of information. We’ll comment on the two key pieces of information.</p>
<ol>
<li>
<p>We look through the implementors of <code>FromRequestParts</code>; this being the Argus-identified error, but no impl block seemed to preserve our intent of extracting a <code>LoginAttempt</code> from request headers. It’s vague to say “nothing seemed right,” and of course fixing a type error may require some familiarity with the crate you’re using or the domain in which you’re working.</p>
</li>
<li>
<p>Instead of implementing <code>FromRequestParts</code> it turns out we can also implement <code>FromRequest</code>. We determined this by expanding the Bottom-Up view to reveal that the bound <code>FromRequest</code> was first a constraint to implement <code>Handler</code>, and that <code>FromRequestParts</code> is an attempt to satisfy the <code>FromRequest</code> bound. Here’s an annotated image of the Top-Down view to highlight the relationship between these two traits.</p>
 <p style="text-align:center"><img src="assets/axum-hello-server/from-rqst-prts-annotated.png" alt="FromRequestParts provenance" width="600"></p>
</li>
</ol>
<p>Finally, after all of these errors, we have a type correct program. All of this work to get a type-correct program, you can use your free time to implement the actual functionality if you wish.</p>
<h1 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h1>
<p>Rust uses a mechanism called traits to define units of shared behavior. We implement traits for types with impl blocks.</p>
<p>The <em>trait solver</em> searches through available impl blocks to determine if a given type implements a specified trait. Tracing the steps made by the trait solver is what we call the <em>search tree,</em> the core data structure exposed by the Argus IDE extension.</p>
<p>The Argus interface shows the search tree either Top-Down or Bottom-Up. The Top-Down view is the search tree as generated by the trait solver. The Bottom-Up view inverts the search tree and traverses the tree from leaves to root. The list icon next to a node shows all impl blocks for the trait in that node.</p>
<p>In the next chapter we’ll show off more features of Argus and debug a Diesel trait error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-methods-and-typestate"><a class="header" href="#trait-methods-and-typestate">Trait Methods and Typestate</a></h1>
<p>Every programming language cultivates its own set of patterns. One pattern common in Rust is the <em>builder pattern.</em> Some data structures are complicated to construct, they may require a large number of inputs, or have complex configuration; the builder pattern helps construct complex values.</p>
<p>A great example of working with builders is the Diesel <a href="https://docs.rs/diesel/latest/diesel/prelude/trait.QueryDsl.html"><code>QueryDsl</code></a>. The <code>QueryDsl</code> trait exposes a number of methods to construct a valid SQL query. Each method consumes the caller, and returns a type that itself implements <code>QueryDsl</code>. As an example here’s the method signature for <code>select</code></p>
<pre><code class="language-rust ignore">fn select&lt;Selection&gt;(self, selection: Selection) -&gt; Select&lt;Self, Selection&gt;
  where 
    Selection: Expression,
    Self: SelectDsl&lt;Selection&gt; { /* ... */ }</code></pre>
<p>The <code>QueryDsl</code> demonstrates the complexity allowed by the builder pattern, it ensures valid SQL queries by encoding query semantics in Rust traits. One drawback of this pattern is that error diagnostics become difficult to understand as your types get larger and the traits involved more complex. In this chapter we will walk through how to debug and understand a trait error involving the builder pattern, or as some people will call it, <em>typestate.</em> We refer to this pattern as typestate because each method returns a type in a particular state, the methods available to the resulting type depend on its state. Calling methods in the wrong order, or forgetting a method, can result in the wrong state for the next method you’d like to call. Let’s walk through an example.</p>
<pre><code class="language-rust ignore">table! {
    users(id) {
        id -&gt; Integer,
        name -&gt; Text,
    }
}

table! {
    posts(id) {
        id -&gt; Integer,
        name -&gt; Text,
        user_id -&gt; Integer,
    }
}

fn query(conn: &amp;mut PgConnection) {
    users::table
        .filter(users::id.eq(posts::id))
        .select((
            users::id,
            users::name,
        ))
        .load::&lt;(i32, String)&gt;(conn);
}</code></pre>
<p>Running <code>cargo check</code> produces the following verbose diagnostic.</p>
<pre><code class="language-text">error[E0271]: type mismatch resolving `&lt;table as AppearsInFromClause&lt;table&gt;&gt;::Count == Once`
    --&gt; src/main.rs:29:32     
     |
29   | ...  .load::&lt;(i32, String)&gt;(con...
     |       ----                  ^^^^ expected `Once`, found `Never`
     |       |
     |       required by a bound introduced by this call
     |
note: required for `posts::columns::id` to implement `AppearsOnTable&lt;users::table&gt;`
    --&gt; src/main.rs:16:9      
     |
16   | ...   id -&gt; ...
     |       ^^
     = note: associated types for the current `impl` cannot be restricted in `where` clauses
     = note: 2 redundant requirements hidden
     = note: required for `Grouped&lt;Eq&lt;..., ...&gt;&gt;` to implement `AppearsOnTable&lt;users::table&gt;`
     = note: required for `WhereClause&lt;Grouped&lt;...&gt;&gt;` to implement `diesel::query_builder::where_clause::ValidWhereClause&lt;FromClause&lt;users::table&gt;&gt;`
     = note: required for `SelectStatement&lt;FromClause&lt;...&gt;, ..., ..., ...&gt;` to implement `Query`
     = note: required for `SelectStatement&lt;FromClause&lt;...&gt;, ..., ..., ...&gt;` to implement `LoadQuery&lt;'_, _, (i32, std::string::String)&gt;`
note: required by a bound in `diesel::RunQueryDsl::load`
    --&gt; diesel-2.1.6/src/query_dsl/mod.rs:1542:15
     |
1540 | ...fn load&lt;'query, U&gt;(self, conn: &amp;mut Con...
     |       ---- required by a bound in this associated function
1541 | ...where
1542 | ...    Self: LoadQuery&lt;'query, Conn, 
...                  
     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `RunQueryDsl::load`
     = note: the full name for the type has been written to 'bad_select-fa50bb6fe8eee519.long-type-16986433487391717729.txt'
</code></pre>
<p>As we did in the previous section, we shall demo a short workflow using Argus to gather the same information. Opening the Argus panel works a little differently, as you shall see in the following video. When there isn’t a link to the obligation in the error tooltip, you can always open Argus from the Command Palette or the bottom toolbar.</p>
<video controls>
  <source alt="Opening the Argus panel" src="assets/diesel-bad-select/open-argus.mp4" type="video/mp4" />
</video>
<p>Below we see that Argus presents <em>more</em> failing bounds than the compiler did. To debug effectively with Argus you should consider all failing founds in the context of your problem and start with the one that is most relevant. You can also compare the failing bound with information provided in the Rust error diagnostic to get you on the right track.</p>
<div id="admonition-important" class="admonition admonish-tip" role="note" aria-labelledby="admonition-important-title">
<div class="admonition-title">
<div id="admonition-important-title">
<p>Important</p>
</div>
<a class="admonition-anchor-link" href="typestate.html#admonition-important"></a>
</div>
<div>
<p><strong>Argus may present more errors than the Rust compiler,</strong> it is research software after all. Use your judgement to decide which errors are first worth exploring, if there are multiple, look at all of them before diving down into one specific search tree. We’re working hard to reduce noise produced by Argus as much as possible.</p>
</div>
</div>
<video controls>
  <source alt="Failing bounds in Argus" src="assets/diesel-bad-select/failing-bounds.mp4" type="video/mp4" />
</video>
<p>Now let’s dive into the trait error.</p>
<video controls>
  <source alt="Diesel finding bug" src="assets/diesel-bad-select/find-bug.mp4" type="video/mp4" />
</video>
<p>Here are some key points from above that we’d like to highlight</p>
<ol>
<li>
<p>When opening the Argus debugger the hover tooltip said “Expression contains unsatisfied trait bounds,” but  there wasn’t a link to jump to the error. This is an unfortunate circumstance, but one that does occur. In these cases you can open the Argus panel by clicking the Argus status in the bottom information bar, or run the command ‘Argus: Inspect current file’ in the command palette.</p>
</li>
<li>
<p>The printed types in Rust can get painfully verbose, the Rust diagnostic even <em>wrote types to a file</em> because they were too long. Argus shortens and condenses type information to keep the panel as readable as possible. One example of this is that fully-qualified identifiers, like <code>users::columns::id</code> prints shortened as <code>id</code>. On hover, the full path is shown at the bottom of the Argus panel in our mini-buffer. Extra information or notes Argus has for you are printed in the mini-buffer, so keep an eye on that if you feel Argus isn’t giving you enough information.</p>
</li>
<li>
<p>Clicking the tree icon next to a node in the Bottom-Up view jumps to that same node in the Top-Down view. This operation is useful if you want to gather contextual information around a node, but don’t want to search the Top-Down tree for it. You can get there in one click.</p>
</li>
</ol>
<p>Turns out we forgot to join the <code>users</code> and <code>posts</code> tables! At this point we understand and have identified the error, now it’s time to fix the program. Unfortunately Argus provides no aide to <em>fix</em> typestate errors. We’re in the wrong state, <code>posts::id</code> doesn’t appear in the table we’re selecting from, we need to get it on the selected-from table. This is a great time to reach for the Diesel documentation for <a href="https://docs.rs/diesel/latest/diesel/prelude/trait.QueryDsl.html"><code>QueryDsl</code></a>.</p>
<video controls>
  <source alt="Diesel fixing typestate error" src="assets/diesel-bad-select/fixed-error.mp4" type="video/mp4" />
</video>
<p>Here we used our domain knowledge of SQL to find the appropriate join methods. We decided to use an <code>inner_join</code> to join the tables, and then all was fixed.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="typestate.html#admonition-note"></a>
</div>
<div>
<p>Finding the appropriate method to change the typestate won’t always be so straightforward. If you lack domain knowledge or are unfamiliar with the terms used in the library, you may have to read more of the documentation and look through examples to find appropriate fixes. When in doubt, try something! And use Argus to continue debugging.</p>
</div>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
